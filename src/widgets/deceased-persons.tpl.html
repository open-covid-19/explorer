<!-- Wrap the whole widget into a DIV -->
<div id="deceased-persons" style="visibility: hidden;">
    <p style="text-align: end; font-size: small;">
        Mortality rate is computed using a 14-day moving average
    </p>
    <div class="spacer"></div>
    <div class="spacer"></div>

    <script async>

        (async function () {
            const rollingWindowSize = 14;
            const minRows = 20 + rollingWindowSize;
            const columns = ['new_confirmed', 'new_deceased'];
            const rootElement = document.currentScript.parentElement;
            const title = `Deceased persons and mortality rate`;

            // Get the location key from the URL
            const locationKey = new URLSearchParams(location.search).get('key');

            // Load the location data using the location key
            let locationData = await loadLocationData(locationKey);

            // Early exit: there is not enough relevant data for this chart
            if (locationData.filter(row => columns.every(col => row[col] && row[col] !== '')).length < minRows) {
                console.error('Not enough records found for columns:', columns);
                rootElement.style.display = 'none';
                return;
            }

            // Convert the relevant rows to numbers
            locationData = mapToNumeric(locationData, columns, true);

            // Get rid of irrelevant data according to settings
            const indices = new Set(filterDataIndices(locationData, rollingWindowSize * 2));
            locationData = locationData
                .filter((_, idx) => indices.has(idx))
                .filter(row => columns.some(col => !Number.isNaN(row[col])));

            // Use a moving average for the mortality rate to avoid spikes
            let cumulativeDeaths = 0;
            const data = locationData.map((row, idx) => {
                const record = {
                    ['Date']: row.date,
                    ['Deceased Persons']: row.new_deceased,
                    ['Mortality Rate']: Number.NaN,
                };

                // Increment cumulative count of deaths
                cumulativeDeaths += Number.isNaN(row.new_deceased) ? 0 : row.new_deceased;

                if (idx > rollingWindowSize * 2) {
                    // Use the 14-day rolling average of deceased cases
                    const startIdxNumerator = Math.max(0, idx - rollingWindowSize);
                    const rollingSumNumerator = locationData.slice(startIdxNumerator, idx)
                        .reduce((total, row) => total + row.new_deceased, 0);

                    // Use the *prior* 14-day rolling average of confirmed cases
                    const startIdxDenominator = Math.max(0, idx - rollingWindowSize * 2);
                    const rollingSumDenominator = locationData.slice(startIdxDenominator, idx)
                        .reduce((total, row) => total + (row.new_confirmed || row.new_deceased), 0);

                    const mortalityRate = Math.min(1, rollingSumNumerator / (rollingSumDenominator || 1));

                    if (cumulativeDeaths < 25) {
                        // Only compute mortality rate if there are at least 25 cumulative deaths
                        record['Mortality Rate'] = 0;
                    } else if (mortalityRate < 0.5) {
                        // Avoid charting suspiciously high mortality rates
                        record['Mortality Rate'] = Math.min(
                            1, rollingSumNumerator / (rollingSumDenominator || 1));
                    } else {
                        record['Mortality Rate'] = Number.NaN;
                    }
                }

                return record;
            }).slice(rollingWindowSize * 2);

            await loadGoogleCharts(['corechart']);
            const elem = attachElement('div', {}, rootElement, prepend = true);
            const chartObject = new google.visualization.ComboChart(elem);
            chartObject.draw(recordsToDataTable(data), Object.assign({}, GOOGLE_CHARTS_CONFIG, {
                title: chartLabel(title),
                colors: ['#D32F2F', '#757575'],  // material teal, material indigo
                curveType: 'function',
                series: {
                    0: { targetAxisIndex: 0, type: 'bars' },
                    1: { targetAxisIndex: 1, type: 'line' },
                },
                vAxes: {
                    1: {
                        textPosition: 'in',
                        viewWindow: {
                            min: 0,
                            max: 0.5,
                        }
                    },
                },
            }));

            // Unhide element
            rootElement.style.visibility = 'visible';
        })();
    </script>
</div>